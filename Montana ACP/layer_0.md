# Слой 0 — Вычислительные ограничения для Montana

**Версия:** 2.7
**Дата:** Январь 2026
**Протокол:** Atemporal Coordinate Presence (ACP)
**Зависимость:** Слой -1 v3.2

---

## L-0.0 Область применения

Данный документ определяет вычислительные ограничения, используемые протоколом Montana.

**Связь со Слоем -1:**

| Слой -1 (Физика) | Слой 0 (Вычисления) |
|------------------|---------------------|
| Физические ограничения | Вычислительные ограничения |
| Эмпирическая верификация | Математическое доказательство или гипотеза |
| Точность 10⁻¹⁷ — 10⁻¹⁹ | «Не сломано за N лет» |

**Критерии включения:**
1. Математическое доказательство или длительная криптоаналитическая проверка
2. Ограничение возможностей противника
3. Применимость к криптографическим протоколам

---

## L-0.0.1 Классификация

| Тип | Определение | Уверенность |
|-----|-------------|-------------|
| A | Доказано безусловно | Математическая |
| B | Доказано относительно допущения | Условная |
| C | Эмпирическая стойкость | Высокая |
| D | Гипотеза | Консенсус экспертов |
| P | Физическое ограничение | Как Слой -1 |

**Порядок уверенности:** A > P > B > C > D

---

## L-0.1 Информационно-теоретические границы

**Стабильность:** Вечная (математические теоремы)
**Тип:** A

### L-0.1.1 Граница Шеннона

**Ограничение:** Сообщение с энтропией H бит имеет минимальный размер сжатия H бит (сжатие ниже = потеря информации).

**Источник:** Shannon (1948).

**Применение в Montana:** Подписи и хеши имеют минимальный размер, равный их энтропии.

### L-0.1.2 Граница дней рождения

**Ограничение:** Для функции H: X → Y с |Y| = N, коллизия ожидается после O(√N) запросов.

**Количественная оценка:**

| Размер выхода | Граница коллизий |
|---------------|------------------|
| 256 бит | 2¹²⁸ запросов |
| 384 бит | 2¹⁹² запросов |

**Применение в Montana:** Размер выхода SHA3-256 определяет потолок безопасности хешей.

### L-0.1.3 Граница Гровера

**Ограничение:** Квантовый поиск даёт максимум квадратичное ускорение (√N).

**Источник:** Bennett et al. (1997) — доказательство оптимальности.

**Применение в Montana:** 256-бит хеш имеет 128-бит квантовую безопасность. Достаточно.

---

## L-0.2 Физические границы вычислений

**Стабильность:** Как Слой -1
**Тип:** P

### L-0.2.1 Граница Ландауэра

**Ограничение:** Вычисление, стирающее N бит при температуре T, требует энергии ≥ N × kT ln(2).

**Вывод:** Из L-1.1 (упорядоченность координат).

**Количественная оценка при T = 300K:**

| Операций | Минимальная энергия | Контекст |
|----------|---------------------|----------|
| 2¹²⁸ | 9.8 × 10¹⁷ Дж | Годовое потребление Земли: 6 × 10²⁰ Дж |
| 2²⁵⁶ | 3.3 × 10⁵⁶ Дж | Годовой выход Галактики: 10⁴⁴ Дж |

**Применение в Montana:** Перебор ключей подписи (ML-DSA) физически невозможен.

### L-0.2.2 Подписи принимаются только для текущего τ₂

**Ограничение:** Подпись в координатной позиции T требует существования в T.

**Вывод:** Из L-1.1 (координаты упорядочены) + L-1.2 (координаты наблюдаемы).

**Механизм:**

Двухслойная архитектура времени:

```
Слой 1: Внутренний порядок (первичный)
├── Хеш-цепь таймслайсов определяет порядок
├── Каждый τ₂ ссылается на предыдущий через prev_hash
├── Узел подписывает координату с привязкой к цепи
├── P2P-аттестация: подпись распространяется немедленно
└── presence_root фиксирует полученные подписи

Слой 2: NMI-калибровка (вторичный, advisory)
├── Узел опрашивает 21 NMI-источник
├── Принимает медиану если ≥14 согласованы в пределах 500ms
├── Калибрует timestamp к SI-секундам
└── При недоступности NMI — цепь продолжает по внутреннему порядку
```

Механизм привязки к текущему τ₂:
- Сеть синхронизирована: все узлы знают текущий τ₂
- Подписи принимаются только для текущего τ₂ (окно 10 минут)
- После закрытия τ₂ → presence_root зафиксирован в хеш-цепи
- prev_slice_hash привязывает подпись к конкретному τ₂ в цепи

**14 дней требуют 14 дней реального времени:**
```
Атакующий хочет: 20,160 подписей (14 дней)
Сеть принимает:  максимум 10 подписей за τ₂ (10 минут)

Даже с бесконечными ресурсами:
├── Можно подписать 1000 координат за секунду
├── Но сеть примет только 1 подпись на минуту
├── 14 дней = 14 дней реального времени
└── Время — ресурс, распределённый равномерно
```

**Структура доказательства присутствия:**

```
PresenceProof(T) = {
    timestamp:      T (координата)
    node_tier:      тир узла (Full/Light/Client)
    timeslice_tier: тир слайса (τ₁/τ₂/τ₃/τ₄)
    prev_slice_hash: хеш предыдущего τ₂ (привязка к цепи)
    signature:      ML-DSA-65(timestamp || node_tier || timeslice_tier || prev_slice_hash)
}
```

**Механизмы защиты:**

| Атака | Защита |
|-------|--------|
| Подписать прошлую координату T-k | P2P сеть принимает подписи только в реальном времени |
| Подделать время получения | presence_root фиксирует полученные подписи в хеш-цепи |
| Накопить подписи заранее | prev_slice_hash создаётся при закрытии предыдущего τ₂ |
| Внедрить подпись в старый слайс | Слайс подписан победителем, хеш-цепь фиксирована |

**Формализация:**
```
Sig(T) включена в presence_root(τ₂) ⟺ сеть получила Sig(T) до закрытия τ₂
Sig(T) после закрытия τ₂ → исключается из presence_root(τ₂)
```

**Применение в Montana:** Накопленные подписи = доказательство присутствия. Хеш-цепь таймслайсов + P2P-аттестация привязывают подписи к координатам.

---

## L-0.3 Классы вычислительной сложности

**Стабильность:** 50+ лет
**Тип:** D (гипотеза) или C (эмпирика)

### L-0.3.1 Односторонние функции существуют

**Ограничение:** Существуют функции, вычислимые за полиномиальное время, обращение которых требует сверхполиномиального времени.

**Тип:** D

**Статус:** 50+ лет эмпирической стойкости. Основа криптографии.

**Применение в Montana:** Хеш-функции, подписи.

### L-0.3.2 Стойкие к коллизиям хеш-функции существуют

**Ограничение:** Существуют семейства функций, где нахождение коллизий требует сверхполиномиального времени.

**Тип:** D + C

**Квантовые атаки на хеш-функции:**

| Атака | Классическая | Квантовая | Источник |
|-------|--------------|-----------|----------|
| Preimage (найти m по H(m)) | O(2ⁿ) | O(2^{n/2}) | Grover |
| Collision (найти m₁≠m₂: H(m₁)=H(m₂)) | O(2^{n/2}) | O(2^{n/3}) | BHT |

**Текущие стойкие семейства:**

| Семейство | Выход | Preimage (класс/кв) | Collision (класс/кв) |
|-----------|-------|---------------------|----------------------|
| SHA-3 | 256 бит | 2²⁵⁶ / 2¹²⁸ | 2¹²⁸ / 2⁸⁵ |
| SHA-3 | 384 бит | 2³⁸⁴ / 2¹⁹² | 2¹⁹² / 2¹²⁸ |

**Применение в Montana:**

| Применение | Требуемая стойкость | SHA3-256 квантовая |
|------------|---------------------|---------------------|
| Хеши блоков | Preimage | 2¹²⁸ (достаточно) |
| Корни Меркла | Collision | 2⁸⁵ (достаточно) |
| Связывание подписей | Preimage | 2¹²⁸ (достаточно) |

### L-0.3.3 Решёточные задачи сложны

**Ограничение:** Эффективное решение LWE, MLWE, SIS требует сверхполиномиального времени.

**Тип:** C + D

**Статус:**
- Постквантово стойкие — квантовое ускорение минимально
- Основа стандартов NIST PQC (ML-KEM, ML-DSA)
- 20+ лет криптоанализа

**Источник:** Regev (2005), Lyubashevsky (2010).

**Применение в Montana:** ML-DSA подписи узлов, ML-KEM обмен ключами.

### L-0.3.4 Постквантовые примитивы

**Montana использует только NIST PQC примитивы:**
- ML-DSA-65 (FIPS 204) — все подписи
- ML-KEM-768 (FIPS 203) — обмен ключами
- SHA3-256 (FIPS 202) — хеш-функции

Классические схемы (RSA, ECDSA) уязвимы к алгоритму Шора.

---

## L-0.4 Примитивы Montana

**Стабильность:** 10-30 лет
**Тип:** C

### L-0.4.1 Хеш-функции

| Примитив | Стандарт | Применение |
|----------|----------|------------|
| SHA3-256 | FIPS 202 | Хеши блоков, корни Меркла |
| SHAKE256 | FIPS 202 | Расширяемый выход |

### L-0.4.2 Цифровые подписи

| Примитив | Стандарт | Применение |
|----------|----------|------------|
| ML-DSA-65 | NIST FIPS 204 | Все подписи (присутствие, транзакции) |

**Размеры ML-DSA-65:**
- Публичный ключ: 1952 байт
- Подпись: 3309 байт
- Безопасность: 128 бит (классическая и квантовая)
- Категория: NIST Category 3

**Применение в Montana:** Каждую минуту узел подписывает свою координатную позицию.

### L-0.4.3 Инкапсуляция ключей

| Примитив | Стандарт | Применение |
|----------|----------|------------|
| ML-KEM-768 | NIST FIPS 203 | Обмен ключами между узлами |

---

## L-0.5 Доказательство присутствия

**Ключевая конструкция Montana:**

### Определение

Присутствие в координатах T₁...Tₙ доказывается набором подписей:

```
Proof(T₁...Tₙ) = {Sig_k(T₁), Sig_k(T₂), ..., Sig_k(Tₙ)}
```

где Sig_k — подпись ключом k, созданная в координатной позиции Tᵢ.

### Свойства

| Свойство | Обеспечивается |
|----------|----------------|
| Неподделываемость | L-0.3.3 (решёточные задачи сложны) |
| Необратимость | L-1.1 (координаты упорядочены) |
| Наблюдаемость | L-1.2 (NMI аттестует позицию) |
| Накопление | L-0.2.2 (подписи только для текущего τ₂) |

### Адаптивный кулдаун

```
Кулдаун определяется медианой регистраций в скользящем окне τ₃.

Свойства кулдауна:
- Скользящее окно: τ₃ (14 дней)
- Диапазон: 1 τ₂ (10 мин) — 180 дней
- Подписи привязаны к текущему τ₂ (L-1.1)
- Подписи криптографически защищены (L-0.3.3)
```

**Бинарность таймслайса (протокольное ограничение):**

```
Присутствие в τ₁ = {0, 1}

10 подписей за 1 минуту  = 1 присутствие в τ₁
1000 подписей за 1 минуту = 1 присутствие в τ₁
1 подпись за 1 минуту     = 1 присутствие в τ₁

Вес определяется количеством занятых таймслайсов (бинарность τ₁).
```

Бинарность τ₁ определяет протокольную ценность подписи.

### Replay protection

**Вопрос:** Что мешает переиспользовать валидную подпись Sig(T)?

**Структура подписи:**
```
PresenceProof(T) = {
    timestamp:       T                    ← координата зафиксирована
    node_tier:       тир узла
    timeslice_tier:  тир слайса
    prev_slice_hash: хеш предыдущего τ₂   ← привязка к цепи
    signature:       ML-DSA-65(...)
}
```

**Защита:**

| Атака | Защита |
|-------|--------|
| Использовать Sig(T) для T' | Timestamp фиксирован в подписанном сообщении |
| Использовать Sig(T) дважды для T | Бинарность τ₁: одна подпись на минуту |
| Подпись для прошлого слайса | prev_slice_hash привязывает к текущему τ₂ |

Replay protection встроена в структуру: timestamp привязывает к координате, prev_slice_hash привязывает к цепи, бинарность делает повторы бесполезными.

### P2P-аттестация

**Механизм включения подписи в presence_root:**

```
1. Узел создаёт PresenceProof(T)
2. Узел рассылает proof всем peers (gossip)
3. Peers проверяют:
   ├── Подпись валидна (ML-DSA-65)
   ├── Timestamp в пределах текущего τ₂
   ├── prev_slice_hash = хеш последнего закрытого τ₂
   └── Proof от этого узла для этой минуты ещё отсутствует
4. Валидные proofs накапливаются в локальном пуле
5. При закрытии τ₂ победитель формирует presence_root из пула
```

**Почему P2P-аттестация работает:**

| Свойство | Гарантия |
|----------|----------|
| Синхронность | Proof должен прийти до закрытия τ₂ |
| Уникальность | Один proof на узел на τ₁ |
| Верифицируемость | Любой узел может проверить подпись |
| Неизменность | После закрытия τ₂ presence_root фиксирован в цепи |

**Окно включения:**

```
τ₂ = 10 минут = 600 секунд

Proof для минуты M должен быть получен сетью до закрытия τ₂
Опоздавший proof → исключается → минута учитывается в следующем τ₂
```

Привязка присутствия к реальному времени обеспечивается P2P-сетью.

### Агрегация и хранение подписей присутствия

**Оптимизация:** Агрегация подписей через чекпоинты.

| Период | Подписей | Размер (3309 байт каждая) |
|--------|----------|---------------------------|
| τ₃ (14 дней) | 20,160 | 66.7 МБ |
| 1 год | 525,600 | 1.74 ГБ |
| τ₄ (4 года) | 2,102,400 | 6.96 ГБ |

**Решение: Координатные чекпоинты**

```
Каждые τ₃ (14 дней):

1. Узел строит Merkle-дерево своих подписей за период:

   MerkleRoot(τ₃_i) = Root({Sig(T₁), Sig(T₂), ..., Sig(T₂₀₁₆₀)})

2. Узел публикует чекпоинт:

   Checkpoint(τ₃_i) = {
       node_id:         публичный ключ
       period:          индекс τ₃
       presence_count:  количество подписанных τ₁
       merkle_root:     32 байта (SHA3-256)
       signature:       ML-DSA-65(period || presence_count || merkle_root)
   }

3. Сеть подтверждает чекпоинт (другие узлы видели подписи)

4. После подтверждения:
   - Индивидуальные подписи можно удалить
   - Хранится только чекпоинт
```

**Хранение после оптимизации:**

| Период | Чекпоинтов | Размер |
|--------|------------|--------|
| τ₃ (14 дней) | 1 | ~3.4 КБ |
| 1 год | 26 | ~88 КБ |
| τ₄ (4 года) | 104 | ~350 КБ |

**Сжатие:** 6.96 ГБ → 350 КБ (×20,000)

**Верификация присутствия:**

| Запрос | Механизм |
|--------|----------|
| Текущий τ₃ | Полные подписи (rolling window) |
| Прошлые τ₃ | Чекпоинт + Merkle proof при необходимости |
| Оспаривание | Узел предоставляет Merkle proof для конкретного T |

**Свойства:**

| Свойство | Гарантия |
|----------|----------|
| Целостность | Merkle root связывает все подписи |
| Компактность | O(1) хранение на период |
| Верифицируемость | Merkle proof для любой подписи |
| Pruning | Безопасное удаление после подтверждения |

### Хранение транзакций

**Структура транзакции:**

```
Transaction = {
    sender:      публичный ключ (1952 байта)
    receiver:    публичный ключ (1952 байта)
    amount:      uint64 (8 байт)
    timestamp:   координата T (8 байт)
    nonce:       uint64 (8 байт)
    signature:   ML-DSA-65 (3309 байт)
}

Размер: ~7.2 КБ на транзакцию
```

**Модель хранения: UTXO**

```
UTXO = {
    tx_hash:     SHA3-256 (32 байта)
    index:       uint32 (4 байта)
    owner:       публичный ключ (1952 байта)
    amount:      uint64 (8 байт)
}

Размер: ~2 КБ на UTXO
```

**Агрегация транзакций:**

```
Каждые τ₂ (10 минут):

1. Транзакции за период → Merkle-дерево:

   TxRoot(τ₂_i) = Root({Tx₁, Tx₂, ..., Txₙ})

2. Блок τ₂:

   Block(τ₂_i) = {
       prev_hash:    хеш предыдущего блока
       tx_root:      корень Merkle транзакций
       presence_root: корень Merkle подписей присутствия
       timestamp:    координата T
       signature:    ML-DSA-65
   }
```

**Pruning транзакций:**

| Данные | Хранение | Условие удаления |
|--------|----------|------------------|
| Полные транзакции | Rolling window (τ₃) | После включения в чекпоинт |
| UTXO set | Постоянно | При трате |
| Merkle roots | Постоянно | Хранятся всегда |

**Оценка хранения (1000 tx/день):**

| Период | Транзакций | Полный размер | После pruning |
|--------|------------|---------------|---------------|
| τ₃ (14 дней) | 14,000 | 100 МБ | 100 МБ (window) |
| 1 год | 365,000 | 2.6 ГБ | ~50 МБ (UTXO) |
| τ₄ (4 года) | 1,460,000 | 10.5 ГБ | ~50 МБ (UTXO) |

---

## L-0.6 Модель противника

**Расширение L-1.6 (физическая модель):**

### Классический противник

**Может:**
- Выполнять любые полиномиальные алгоритмы
- Создавать произвольное количество идентичностей
- Контролировать сетевые соединения

**Ограничен (при условии C/D):**
- Подделка подписей ML-DSA требует ~2^192 операций
- Коллизии SHA3-256 требуют ~2^128 операций
- Присутствие ограничено текущим τ₂

### Квантовый противник

**Может:**
- Использовать алгоритм Гровера (√N ускорение)

**Ограничен (при условии A/C/D):**
- Решёточные задачи (ML-DSA, ML-KEM) сохраняют стойкость
- Ускорение ограничено границей Гровера (√N)

### Sybil-атака

**Может:**
- Создать 1000 идентичностей

**Ограничен:**
- Координатное присутствие = 1 подпись на τ₁ (L-0.2.2)
- Адаптивный кулдаун = реальное время (L-1.1 + L-1.2)

---

## L-0.7 Модель сети

**Стабильность:** Зависит от выбора
**Тип:** N (network-dependent)

### L-0.7.1 Синхронность

Montana работает в модели **частичной синхронности** (partial synchrony).

```
До GST (Global Stabilization Time):
├── Сообщения могут задерживаться произвольно
├── Узлы могут расходиться во view
└── Безопасность (safety) сохраняется

После GST:
├── Сообщения доставляются за Δ
├── Сеть сходится к единому view
└── Живучесть (liveness) гарантирована
```

**Параметры:**

| Параметр | Значение | Обоснование |
|----------|----------|-------------|
| Δ (ожидаемая задержка) | <30 секунд | P2P gossip глобально |
| τ₂ (окно слайса) | 10 минут | >>Δ, достаточно для сходимости |
| GST | Неизвестен | Стандартная модель |

### L-0.7.2 Гарантии

```
Safety (безопасность):
├── Всегда: один presence_root на τ₂ (через fork-choice)
├── Fork-choice rule разрешает разногласия
└── Гарантируется независимо от GST

Liveness (живучесть):
├── После GST: подписи включаются в presence_root
├── До GST: возможны пропуски
└── Зависит от сетевой связности
```

**FLP:** Montana использует fork-choice rule для eventual consistency (детерминированный консенсус каждого шага опционален).

---

## L-0.8 Параметр безопасности

### L-0.8.1 Определение

```
λ = 128 бит (минимальный уровень безопасности)

Все примитивы параметризованы для ≥λ бит безопасности:
├── SHA3-256: 128 бит (collision), 256 бит (preimage)
├── ML-DSA-65: ~128 бит (NIST Level 3)
├── ML-KEM-768: ~128 бит (NIST Level 3)
```

### L-0.8.2 Конкретная безопасность

| Атака | Примитив | Работа атакующего | Преимущество |
|-------|----------|-------------------|--------------|
| Подделка подписи | ML-DSA-65 | ~2^192 операций | negl(λ) |
| Коллизия хеша | SHA3-256 | ~2^128 операций | negl(λ) |
| Preimage хеша | SHA3-256 | ~2^256 операций | negl(λ) |
| Взлом KEM | ML-KEM-768 | ~2^192 операций | negl(λ) |

### L-0.8.3 Квантовая безопасность

```
Post-quantum λ_q = 128 бит

Grover на SHA3-256: 2^128 квантовых операций
Lattice attacks: Квантовая стойкость сохранена

Все примитивы Montana ≥128 бит постквантовой безопасности.
```

---

## L-0.9 Генерация ключей и энтропия

### L-0.9.1 Источники энтропии

```
Требования к генерации ключа:
├── ≥256 бит энтропии
├── CSPRNG (криптографически стойкий ГПСЧ)
└── OS entropy pool (/dev/urandom, CryptGenRandom)

Мнемоника (24 слова):
├── BIP-39 совместимая
├── 256 бит энтропии
└── Checksum: 8 бит
```

### L-0.9.2 Деривация ключей

```
seed = PBKDF2(mnemonic, "mnemonic" + passphrase, 2048, SHA-512)

ML-DSA keypair:
├── sk = ML-DSA-65.KeyGen(SHAKE256(seed || "signing"))
└── pk = ML-DSA-65.DerivePublic(sk)

ML-KEM keypair:
├── sk = ML-KEM-768.KeyGen(SHAKE256(seed || "encryption"))
└── pk = ML-KEM-768.DerivePublic(sk)
```

### L-0.9.3 Безопасность деривации

| Компонент | Безопасность | Условие |
|-----------|--------------|---------|
| Мнемоника | 256 бит | Случайный выбор слов |
| PBKDF2 | ≥128 бит | 2048 итераций |
| SHAKE256 | 256 бит | Preimage resistance |

**Цепочка безопасности:**
```
Энтропия OS → Мнемоника → PBKDF2 → seed → SHAKE256 → Ключи
    256 бит       256 бит    ≥128 бит   512 бит   256 бит
```

---

## L-0.10 Domain separation

### L-0.10.1 Контексты подписей

Montana использует разные контексты для разных типов подписей:

```
PresenceProof:
  message = "Montana.Presence.v1" || timestamp || node_tier || prev_slice_hash
  signature = ML-DSA-65.Sign(sk, message)

Transaction:
  message = "Montana.Transaction.v1" || sender || receiver || amount || nonce
  signature = ML-DSA-65.Sign(sk, message)

Checkpoint:
  message = "Montana.Checkpoint.v1" || period || presence_count || merkle_root
  signature = ML-DSA-65.Sign(sk, message)

SliceHeader:
  message = "Montana.Slice.v1" || prev_hash || presence_root || tx_root || timestamp
  signature = ML-DSA-65.Sign(sk, message)
```

### L-0.10.2 Зачем domain separation

| Атака | Защита domain separation |
|-------|--------------------------|
| Использовать Sig(Presence) как Sig(Tx) | Разные prefixes блокируют подмену |
| Cross-protocol атака | Domain-specific prefixes разделяют контексты |
| Replay между версиями | Версия в prefix связывает подпись с протоколом |

### L-0.10.3 Версионирование

```
При обновлении протокола:
├── Новый prefix: "Montana.Presence.v2"
├── Старые подписи действительны только для v1
├── v1 и v2 сосуществуют (transition period)
└── После transition: только v2
```

---

## L-0.11 Malleability

### L-0.11.1 ML-DSA malleability

ML-DSA (Dilithium) имеет **детерминированные подписи**.

```
Для одного сообщения m и ключа sk:
  Sign(sk, m) всегда возвращает одну и ту же σ

Следствие: Защита от malleability
├── Создание σ' ≠ σ такой что Verify(pk, m, σ') = true требует знания sk
└── Каждое (pk, m) имеет ровно одну валидную подпись
```

### L-0.11.2 Влияние на Montana

| Сценарий | Статус |
|----------|--------|
| Transaction malleability | Защита: детерминированные подписи |
| Presence proof malleability | Защита: детерминированные подписи |
| Двойная трата | Защита: детерминированные подписи |

---

## L-0.12 Сводка

| ID | Ограничение | Тип | Роль в Montana |
|----|-------------|-----|----------------|
| L-0.1.2 | Граница дней рождения | A | Размер хешей |
| L-0.1.3 | Граница Гровера | A | Квантовая безопасность |
| L-0.2.1 | Граница Ландауэра | P | Энергетические ограничения перебора |
| L-0.2.2 | Ретроактивное присутствие | P | Накопление подписей |
| L-0.3.2 | Стойкие хеши | D+C | SHA3-256 |
| L-0.3.3 | Решёточные задачи | C+D | ML-DSA, ML-KEM |
| L-0.7 | Модель сети | N | Partial synchrony |
| L-0.8 | Параметр безопасности | — | λ = 128 бит |
| L-0.9 | Генерация ключей | — | BIP-39, PBKDF2 |
| L-0.10 | Domain separation | — | Контексты подписей |
| L-0.11 | Malleability | — | Детерминированные подписи |
| L-0.14 | Адаптивный кулдаун | — | 1 день — 180 дней, сглаживание 4 τ₃, rate limit ±20% |
| L-0.15 | Детерминированный presence_root | — | canonical_order + fork-choice по весу |
| L-0.16 | Genesis | — | Hardcoded block + seed nodes |
| L-0.17 | Eclipse protection | — | Peer diversity + NMI reality check |
| L-0.18 | Детерминированный tx_root | — | Grace period 30 сек, fork-choice |

---

## L-0.13 Постквантовая стратегия

**Решение Montana:** Постквантовые примитивы с генезиса.

| Примитив | Стандарт | Статус |
|----------|----------|--------|
| ML-DSA-65 | FIPS 204 | NIST стандарт 2024 |
| ML-KEM-768 | FIPS 203 | NIST стандарт 2024 |
| SHA3-256 | FIPS 202 | NIST стандарт 2015 |

Montana использует постквантовые примитивы с генезиса.

---

## L-0.14 Адаптивный кулдаун

**Тип:** Протокольное ограничение
**Зависимость:** L-0.2.2 (подписи только для текущего τ₂)

### L-0.14.1 Определение

Адаптивный кулдаун определяется сглаженной медианой регистраций с защитой от манипуляций.

```
Кулдаун = f(сглаженная медиана, rate limit)

Минимум:     1 день (144 τ₂) — вход требует минимум 1 день
Максимум:    180 дней (25,920 τ₂)
Окно:        τ₃ (14 дней) для медианы
Сглаживание: 4 τ₃ (56 дней) скользящее среднее
Rate limit:  ±20% максимальное изменение за τ₃
```

Кулдаун фиксируется в момент регистрации. Каждый тир (Full/Light/Client) имеет независимую медиану.

### L-0.14.2 Защита от манипуляций

```
Три механизма защиты:

1. Минимальный порог (1 день = 144 τ₂):
   ├── Вход требует минимум 1 день даже при пустой сети
   ├── Атакующий тратит минимум 1 день на каждый узел
   └── Sybil-атака растягивается во времени

2. Сглаживание (4 τ₃ = 56 дней):
   ├── Скользящее среднее медиан за 4 τ₃
   ├── Резкий всплеск регистраций размазывается по 56 дням
   └── Манипуляция требует долгосрочных затрат

3. Rate limiting (±20% за τ₃):
   ├── Кулдаун изменяется максимум на 20% за τ₃
   ├── Резкие скачки имеют ограниченный эффект
   └── Сеть адаптируется плавно
```

### L-0.14.3 Формула

```
smoothed_median = average(medians за последние 4 τ₃)
ratio = current_registrations / smoothed_median

Если ratio ≤ 1.0:
    raw_cooldown = MIN + ratio × (MID - MIN)

Если ratio > 1.0:
    raw_cooldown = MID + (ratio - 1) × (MAX - MID)

Rate limit:
    max_change = previous_cooldown × 20%
    cooldown = clamp(raw_cooldown, previous - max_change, previous + max_change)
    cooldown = clamp(cooldown, MIN, MAX)

Константы:
├── MIN = 144 τ₂ (1 день)
├── MID = 1,008 τ₂ (7 дней)
├── MAX = 25,920 τ₂ (180 дней)
├── SMOOTH_WINDOWS = 4 τ₃ (56 дней)
└── RATE_LIMIT = 20%
```

Линейная калибровка с защитой: ниже медианы — быстрый вход, выше медианы — замедление. Сглаживание и rate limit защищают от манипуляций.

### L-0.14.4 Состояния узла

```
NodeState = {
    pubkey:         ML-DSA-65 public key
    node_type:      Full | Light | Client
    cooldown_until: τ₂ index (0 для genesis)
    last_active:    τ₂ index
    is_genesis:     bool
}

Статусы:
├── COOLDOWN:  cooldown_until > current_τ₂
├── ACTIVE:    cooldown_until ≤ current_τ₂
```

### L-0.14.5 Регистрация

```
RegisterNode(pubkey, node_type):
    current = current_τ₂()
    median = get_median(node_type)
    count = registrations_this_τ₂(node_type)

    ratio = count / max(median, 1)
    cooldown = calculate_cooldown(ratio)
    cooldown_until = current + cooldown

    node = NodeState {
        pubkey, node_type,
        cooldown_until,
        last_active: current,
        is_genesis: false
    }

    record_registration(current, node_type)
    update_median(node_type)

    return node
```

### L-0.14.6 Поведение в кулдауне

```
Узел в кулдауне (cooldown_until > current_τ₂):
├── Подписывает координаты (доказывает присутствие)
├── Включён в presence_root (с флагом cooldown_until)
├── Вес накапливается после окончания кулдауна
├── ChainWeight учитывает только active узлы
└── Лотерея доступна после окончания кулдауна

ChainWeight = Σ подписей active узлов.
```

### L-0.14.7 Переходы между тирами

```
Апгрейд тира (Light Client → Light Node → Full Node):
├── Новый кулдаун для нового тира
├── Вес сохраняется
├── Медиана берётся из нового тира
└── Защита от tier-hopping

Пример:
├── Light Client с весом 60,480
├── Апгрейд до Full Node
├── Новый кулдаун по медиане Full Node
└── После кулдауна: вес 60,480 + накопление как Full
```

### L-0.14.8 Реактивация

```
Узел офлайн > τ₃ (14 дней):
├── При возврате: новый кулдаун (как для нового узла)
├── Вес сохранён
├── cooldown = calculate_cooldown(current_ratio)
└── Защита от exit-reenter

needs_reactivation(node) = (current_τ₂ - node.last_active) > τ₃_in_τ₂
```

### L-0.14.9 Медиана

```
Окно медианы: последние τ₃ (2,016 τ₂)

MedianSnapshot = {
    counts_per_τ₂: Vec<(τ₂, count)>  // за окно
    median: u64
    last_τ₂: u64
}

На каждом τ₂:
├── Удалить записи старше окна
├── Добавить текущий count
├── Пересчитать медиану
└── Опубликовать в SliceHeader
```

### L-0.14.10 SliceHeader

```
SliceHeader содержит:
├── cooldown_medians: [u64; 3]   // [Full, Light, Client]
├── registrations: [u64; 3]       // Новые за этот τ₂

Верификация:
├── Любой узел может проверить cooldown узла X
├── median_at_registration известна из chain
├── cooldown детерминирован
```

### L-0.14.11 Sybil-анализ

**Низкая активность (ratio < 1):**
```
Сеть нуждается в узлах
├── Кулдаун минимальный (1 день — 7 дней)
├── Мгновенный вход невозможен (минимум 1 день)
└── Без waitlist, без очереди
```

**Массовая атака (ratio >> 1):**
```
Атакующий регистрирует 1000 узлов:
├── ratio = 1000 / smoothed_median(~10) = 100
├── Сглаживание размазывает эффект по 56 дням
├── Rate limit ограничивает рост 20% за τ₃
├── Все 1000 узлов: кулдаун растёт до 180 дней постепенно
└── Атака растягивается на полгода+

Три уровня защиты:
├── 1-день минимум: мгновенный вход невозможен
├── Сглаживание: манипуляция требует долгосрочных затрат
└── Rate limit: резкие скачки имеют ограниченный эффект
```

### L-0.14.12 Защита ChainWeight

```
ChainWeight = Σ подписей БЕЗ флага cooldown

Узел в кулдауне:
├── Подписи в presence_root
├── ChainWeight учитывает только active узлы
└── Кулдаун изолирует новые узлы от влияния на вес цепи

Fork-choice:
├── ChainWeight (подписи active узлов)
├── При равном весе → длина
├── При равной длине → меньший хеш
```

### L-0.14.13 Genesis

```
День 1 сети:
├── Медиана инициализирована значением M_default
├── M_default = 1 τ₂
├── Genesis nodes: is_genesis = true, кулдаун отсутствует
└── Первые узлы входят быстро

Далее медиана органически настраивается по мере роста сети.
```

### L-0.14.14 Параметры

| Параметр | Значение | Обоснование |
|----------|----------|-------------|
| MIN | 144 τ₂ (1 день) | Минимальный кулдаун, мгновенный вход невозможен |
| MAX | 25,920 τ₂ (180 дней) | Максимальная защита |
| MID | 1,008 τ₂ (7 дней) | Точка перегиба при медиане |
| Окно медианы | τ₃ (2,016 τ₂) | Достаточная статистика |
| Сглаживание | 4 τ₃ (56 дней) | Размазывание манипуляций |
| Rate limit | ±20% за τ₃ | Ограничение резких скачков |
| Per tier | Да | Независимые медианы |
| Реактивация | > τ₃ офлайн | Как для нового узла |

### L-0.14.15 Тройная защита

```
1. Минимальный порог:   1 день — мгновенный вход невозможен
2. Сглаживание:         4 τ₃ (56 дней) — манипуляция размазывается
3. Rate limit:          ±20% за τ₃ — резкие скачки ограничены
4. Накопление веса:     Долгосрочные участники имеют преимущество
```

---

## L-0.16 Genesis

**Тип:** Протокольное ограничение

### L-0.16.1 Genesis block

```
Genesis block (Slice 0):
├── Hardcoded в коде
├── timestamp: T₀ (фиксированная координата)
├── prev_hash: 0x00...00 (32 байта нулей)
├── presence_root: Merkle(genesis_signatures)
├── tx_root: 0x00...00 (нет транзакций)
└── signature: ML-DSA-65(genesis_key)
```

### L-0.16.2 Seed nodes

```
DNS seeds:
├── seed.montana.network
├── dnsseed.montana.network
└── Несколько независимых операторов

Hardcoded fallback:
├── Список IP-адресов в коде
└── Используется если DNS недоступен
```

### L-0.16.3 Bootstrap sequence

```
1. Новый узел читает genesis block (hardcoded)
2. Подключается к seed nodes
3. Скачивает таймчейн от genesis до head
4. Верифицирует каждый слайс:
   ├── prev_hash корректен
   ├── presence_root валиден
   └── signature валидна
5. Начинает подписывать координаты
```

### L-0.16.4 Параметры

| Параметр | Значение |
|----------|----------|
| Genesis timestamp | T₀ (определяется при запуске) |
| Genesis prev_hash | 0x00...00 |
| Seed nodes | ≥3 DNS seeds |
| Fallback IPs | ≥10 hardcoded |

---

## L-0.17 Eclipse protection

**Тип:** Протокольное ограничение
**Зависимость:** L-0.7 (модель сети)

### L-0.17.1 Определение

Eclipse attack: изоляция узла от честной сети.

### L-0.17.2 Эффект в Montana

```
Eclipsed Full Node:
├── Подписывает координаты (локально)
├── Подписи достигают только изолированного сегмента
├── Включаются в presence_root изолированного сегмента
├── Вес сохраняется
├── Накопление приостановлено до восстановления
└── При восстановлении: продолжает нормально

Eclipse = потеря liveness для узла
Безопасность сети сохраняется
```

### L-0.17.3 Механизмы защиты

```
Peer diversity:
├── MIN_OUTBOUND_PEERS = 8
├── MAX_PEERS_PER_IP = 1
├── MAX_PEERS_PER_SUBNET_16 = 4
└── Периодическая ротация peers

NMI reality check:
├── Независимый источник времени
├── Расхождение NMI vs peers = признак Eclipse
└── Warning + reconnect to seeds
```

### L-0.17.4 Детекция

```
Признаки Eclipse:
├── Таймчейн изолирован от основной сети
├── presence_root содержит только локальные подписи
├── NMI расходится с peers
└── Все peers из одной /16 или AS

Реакция:
├── Warning в логах
├── Reconnect к seed nodes
└── Pause signing до восстановления
```

---

## L-0.18 Детерминированный tx_root

**Тип:** Протокольное ограничение
**Зависимость:** L-0.15 (детерминированный presence_root)

### L-0.18.1 Определение

tx_root вычисляется детерминистично из всех валидных транзакций текущего τ₂:

```
tx_root(n) = Merkle(
    sort_by(SHA3-256(tx)),
    {tx : tx.valid ∧ tx.timestamp ∈ τ₂(n) ∧ tx.nonce_valid}
)
```

Победитель лотереи публикует детерминированный результат.

### L-0.18.1.1 tx.timestamp

```
tx.timestamp:
├── Устанавливает: отправитель
├── Цель: определить в какой τ₂ попадает tx
└── Упорядочение определяется hash

Валидация узлами:
├── tx.timestamp ≤ node_time + 30 сек (в пределах grace period)
├── tx.timestamp ≥ current_τ₂.start (в текущем τ₂)
└── tx.timestamp ∈ τ₂(n) → включение в tx_root(n)

Порядок в tx_root:
├── sort_by(SHA3-256(tx)) — только хеш
├── Хеш непредсказуем до подписания tx
└── MEV невозможен
```

### L-0.18.1.2 Детерминированная позиция

```
Отправитель контролирует: в какой τ₂ попадёт tx
Позиция в tx_root: определяется SHA3-256(tx)

Защита от манипуляции timestamp:
├── tx.timestamp в текущем τ₂
├── tx.timestamp в пределах grace period
└── Вне диапазона → reject

Защита от grinding позиции:
├── Порядок = SHA3-256(tx)
├── tx включает подпись
├── Подпись детерминирована от приватного ключа
└── Позиция детерминирована, но непредсказуема заранее
```

### L-0.18.2 Grace period

```
grace_period = 30 секунд после закрытия τ₂

Транзакция включается если:
├── tx.timestamp ∈ τ₂(n)
├── tx получена до (τ₂(n).end + grace_period)
├── tx.valid = true
└── tx.nonce_valid = true

После grace_period → tx_root фиксируется окончательно
```

### L-0.18.3 Механика

```
Период τ₂(n) (10 минут):

1. Узлы создают транзакции с timestamp ∈ τ₂(n)
2. Транзакции распространяются через P2P gossip
3. Каждый узел накапливает tx в mempool
4. При закрытии τ₂(n) + grace_period:
   ├── Все узлы имеют (почти) одинаковый набор tx
   ├── Все вычисляют одинаковый tx_root
   └── Победитель публикует результат

Транзакции включаются по детерминированному правилу.
```

### L-0.18.4 Пропагация

```
Реальность сети:
├── Обычно: <1 секунда глобально
├── Редко: <1 минута (перегрузка, плохая связь)
├── Grace period 30 сек: покрывает 99%+ случаев

Если mempools различаются после grace_period:
├── Разные tx_root → форк
├── ChainWeight решает (по presence_sigs)
├── "Проигравшие" tx: повторная отправка
└── Частота: редко (<1% слайсов)
```

### L-0.18.5 Свойства

| Свойство | Гарантия |
|----------|----------|
| Детерминированность | Все узлы вычисляют одинаковый tx_root |
| Латентность | 0-30 секунд (grace period) |
| Цензуроустойчивость | Детерминированное включение |
| MEV-устойчивость | Порядок детерминирован hash |
| Fork tolerance | ChainWeight решает споры |

### L-0.18.6 Формализация

```
Теорема: tx_root детерминирован при согласованном mempool

∀ узлы A, B с одинаковым набором tx T:
  tx_root_A = tx_root_B = Merkle(sort_by_hash(T))

Доказательство:
1. sort_by(SHA3-256(tx)) детерминирован
2. Merkle tree детерминировано от входного массива
3. SHA3-256 детерминирован
QED

Теорема: MEV невозможен

∀ tx: позиция tx в tx_root непредсказуема до подписания

Доказательство:
1. Позиция = f(SHA3-256(tx))
2. tx включает подпись отправителя
3. Подпись зависит от приватного ключа и содержимого
4. SHA3-256(tx) непредсказуем до создания подписи
5. Позиция определяется hash
QED
```

---

## Литература

Shannon, C.E. (1948). Bell System Technical Journal 27: 379–423.
Bennett, C.H. et al. (1997). SIAM Journal on Computing 26(5): 1510–1523.
Regev, O. (2005). STOC 2005: 84–93.
Lyubashevsky, V. et al. (2010). EUROCRYPT 2010: 1–23.
Landauer, R. (1961). IBM Journal 5(3): 183–191.
Dwork, C., Lynch, N., Stockmeyer, L. (1988). JACM 35(2): 288–323. [Partial Synchrony]
Fischer, M., Lynch, N., Paterson, M. (1985). JACM 32(2): 374–382. [FLP]
BIP-39 (2013). Mnemonic code for generating deterministic keys.
NIST FIPS 202 (2015). SHA-3 Standard.
NIST FIPS 203 (2024). ML-KEM Standard.
NIST FIPS 204 (2024). ML-DSA Standard.

---

## L-0.15 Детерминированный presence_root

**Тип:** Протокольное ограничение
**Зависимость:** L-0.2.2 (подписи только для текущего τ₂), L-0.3.2 (коллизии сложны)

### L-0.15.1 Определение

presence_root вычисляется детерминистично из всех валидных подписей:

```
presence_root(τ₂) = Merkle(
    canonical_order(
        {sig : sig.valid ∧ sig.timestamp ∈ τ₂ ∧ sig.prev_hash = correct}
    )
)
```

Победитель лотереи публикует детерминированный результат.

### L-0.15.2 Каноническое упорядочение

```
canonical_order(signatures) = sort_by(
    (sig.timestamp, SHA3-256(sig))
)

Порядок:
1. Сначала по timestamp (восходящий)
2. При равных timestamp — по хешу подписи (лексикографически)

Результат: детерминированный порядок для любого набора подписей
```

### L-0.15.3 Механика

```
Период τ₂ (10 минут):

1. Узлы подписывают координаты
2. Подписи распространяются через P2P gossip
3. Каждый узел накапливает валидные подписи в локальном пуле
4. При закрытии τ₂:
   ├── Все узлы имеют (почти) одинаковый набор подписей
   ├── Все вычисляют одинаковый presence_root
   └── Победитель публикует результат

Подписи включаются по детерминированному правилу canonical_order.
Победитель публикует результат, который сеть может независимо проверить.
```

### L-0.15.4 Grace period

```
Для подписей на границе τ₂:

grace_period = 30 секунд после закрытия τ₂

Подпись включается если:
├── sig.timestamp ∈ τ₂
├── sig.prev_hash = correct
├── sig получена до (τ₂.end + grace_period)
└── sig.valid = true

После grace_period → presence_root фиксируется окончательно
```

### L-0.15.5 Fork-choice по весу

```
ChainWeight(chain) = Σ len(slice.presence_sigs) для всех слайсов

При форке:
├── Каноническая цепь = max(ChainWeight)
├── Цензура подписей → меньше подписей → легче цепь → проиграет
└── Рациональная стратегия = включить все подписи

Разрешение конфликтов:
1. ChainWeight (больше подписей = лучше)
2. При равном весе → длина цепи
3. При равной длине → меньший хеш head
```

### L-0.15.6 Sybil = участие

```
Sybil создаёт 1000 идентичностей.

Каждая идентичность:
├── Подписывает координаты (как все)
├── Включается в presence_root (как все)
├── Увеличивает ChainWeight (как все)
└── Поддерживает сеть (как все)

Sybil = участие.
Больше подписей = тяжелее цепь = сильнее сеть.
```

### L-0.15.7 Власть победителя

```
Победитель лотереи:
├── Собирает транзакции из mempool → НЕТ ограничений, честная конкуренция
├── Формирует presence_root → детерминированно из подписей
├── Подписывает слайс → ML-DSA-65
└── Публикует → сеть верифицирует независимо

Власть победителя:
├── Включение транзакций

Подписи присутствия:
└── Определяются детерминированно canonical_order
```

### L-0.15.8 Свойства

| Свойство | Гарантия |
|----------|----------|
| Детерминированность | Все узлы вычисляют одинаковый presence_root |
| Цензуроустойчивость | Цензура → легче цепь → проиграет форку |
| Sybil-нейтральность | Sybil = участие, увеличивает вес сети |
| Универсальность | Работает при любом соотношении участников |
| Время = всё | Только координатное присутствие определяет вес |

### L-0.15.9 Формализация

```
Теорема: presence_root детерминирован

∀ узлы A, B с одинаковым набором подписей S:
  presence_root_A = presence_root_B = Merkle(canonical_order(S))

Доказательство:
1. canonical_order детерминирован (sort by timestamp, sig_hash)
2. Merkle tree детерминировано от входного массива
3. SHA3-256 детерминирован
QED
```

```
Теорема: Цензура иррациональна

Пусть победитель цензурирует подпись sig:
  ChainWeight(censored) < ChainWeight(full)

При форке с честным победителем:
  full_chain побеждает censored_chain

Рациональная стратегия = включить все подписи.
QED
```

---

*v2.7: Актуализация с кодом. Унификация терминологии.*
*v2.6: Детали адаптивного кулдауна.*
*v2.5: Защита cooldown от манипуляций: минимум 1 день, сглаживание 4 τ₃, rate limit ±20%.*
*v2.4: Адаптивный кулдаун = скользящее окно τ₃. Документация через утверждения.*
*v2.3: L-0.14 Адаптивный кулдаун расширен.*
*v2.2: Постквантовые примитивы.*
*v2.1: L-0.18: tx.timestamp для τ₂ assignment, порядок по hash (MEV невозможен).*
*v2.0: L-0.18 упрощён: grace period 30 сек (пропагация <1 сек обычно, <1 мин редко).*
*v1.9: L-0.18 расширен: задержка tx_root на один τ₂ для гарантированной пропагации.*
*v1.8: Добавлен L-0.17 Eclipse protection, L-0.18 Детерминированный tx_root.*
