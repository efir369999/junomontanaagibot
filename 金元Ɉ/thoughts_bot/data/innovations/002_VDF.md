# Verifiable Delay Functions in Montana

**Cryptographic Time Proofs**
**Version:** 1.0
**Date:** January 2026

---

## Abstract

Verifiable Delay Functions (VDFs) provide cryptographic proof that a specified amount of sequential computation—and therefore time—has elapsed. This paper describes Montana's implementation of VDFs as the foundation for temporal consensus. We demonstrate how VDFs transform wall-clock time into a verifiable, unforgeable resource.

---

## 1. Introduction

A Verifiable Delay Function is a function f: X → Y with three properties:

1. **Sequential:** Computing f(x) requires T sequential operations
2. **Efficiently Verifiable:** Given x and y, verification takes ≪ T time
3. **Uniquely Determined:** For each x, there exists exactly one valid y

These properties make VDFs ideal for proving temporal passage without trusted timestamps.

---

## 2. Mathematical Foundation

### 2.1 RSA-based Construction

Montana implements the Wesolowski VDF based on repeated squaring in RSA groups:

```
f(x) = x^(2^T) mod N
```

Where:
- N is an RSA modulus (product of two large primes)
- T is the difficulty parameter (number of sequential squarings)
- x is the input challenge

### 2.2 Proof Generation

The prover computes:
```
π = x^(⌊2^T / l⌋) mod N
```

Where l is a prime derived from H(x, y).

### 2.3 Verification

Verifier checks:
```
π^l · x^r ≡ y (mod N)
```

Where r = 2^T mod l.

Verification requires only O(log T) operations.

---

## 3. Integration with ACP

### 3.1 Temporal Anchoring

Each presence proof includes a VDF output anchoring it to elapsed time:

```
PresenceProof = {
    timestamp: T,
    vdf_input: H(prev_block || T),
    vdf_output: VDF(vdf_input, difficulty),
    vdf_proof: π,
    signature: Sig_sk(vdf_output)
}
```

### 3.2 Difficulty Adjustment

Montana adjusts VDF difficulty to maintain τ₂ = 10 minute intervals:

```
new_difficulty = old_difficulty × (target_time / actual_time)
```

Adjustment occurs every 2016 intervals (≈14 days).

---

## 4. Security Properties

### 4.1 Time-Lock Guarantee

**Theorem 2.** An adversary with p parallel processors cannot compute VDF(x, T) faster than T/p sequential operations, where p is bounded by the inherent parallelism of repeated squaring (effectively p ≈ 1).

**Corollary.** No amount of parallel computation can reduce VDF evaluation time below the sequential lower bound.

### 4.2 Attack Resistance

| Attack | Mitigation |
|--------|------------|
| Precomputation | Random challenge from previous block |
| Hardware acceleration | ASICs provide ≤10x speedup |
| Quantum computing | Post-quantum VDFs under research |

---

## 5. Implementation

### 5.1 Parameters

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| Modulus size | 2048 bits | Security margin |
| T (difficulty) | 2^30 | ≈10 min on commodity hardware |
| Hash function | SHA3-256 | NIST standard |

### 5.2 Performance

```
Platform          | VDF Time | Verification
------------------|----------|-------------
Intel i7 (2024)   | 600s     | 0.1s
AMD EPYC          | 580s     | 0.1s
Apple M3          | 550s     | 0.1s
```

---

## 6. Conclusion

VDFs transform time into a cryptographically verifiable resource. By requiring sequential computation, VDFs ensure that producing a valid output inherently requires the passage of wall-clock time. Montana leverages this property to create trustless temporal proofs—the foundation of Atemporal Coordinate Presence.

---

## References

1. Boneh, D., Bonneau, J., Bünz, B., & Fisch, B. (2018). Verifiable Delay Functions.
2. Wesolowski, B. (2019). Efficient Verifiable Delay Functions.
3. Pietrzak, K. (2019). Simple Verifiable Delay Functions.

---

```
Alejandro Montana
Montana Protocol
January 2026
```
