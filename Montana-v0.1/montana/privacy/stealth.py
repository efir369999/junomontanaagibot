"""
ษ Montana Stealth Addresses v3.1

T1 Privacy: Hidden receiver via stealth addresses per ยง14.2.

Stealth addresses allow sender to create one-time addresses
that only the receiver can link to their wallet.
"""

from __future__ import annotations
import hashlib
import secrets
from dataclasses import dataclass
from typing import Tuple, Optional

from montana.core.types import Hash, PublicKey, SecretKey
from montana.crypto.hash import sha3_256, shake256


@dataclass(frozen=True)
class StealthAddress:
    """
    One-time stealth address.

    Generated by sender, spendable only by receiver.
    """
    one_time_public_key: bytes    # 32 bytes - the stealth public key
    tx_public_key: bytes          # 32 bytes - ephemeral key for derivation
    view_tag: bytes               # 1 byte - fast scanning optimization

    def serialize(self) -> bytes:
        """Serialize stealth address."""
        return self.one_time_public_key + self.tx_public_key + self.view_tag

    @classmethod
    def deserialize(cls, data: bytes) -> "StealthAddress":
        """Deserialize stealth address."""
        return cls(
            one_time_public_key=data[:32],
            tx_public_key=data[32:64],
            view_tag=data[64:65],
        )


@dataclass(frozen=True)
class StealthKeys:
    """
    Receiver's stealth key pair.

    Consists of:
    - View key: allows scanning for incoming transactions
    - Spend key: required to spend received funds
    """
    view_secret: bytes    # 32 bytes
    view_public: bytes    # 32 bytes
    spend_secret: bytes   # 32 bytes
    spend_public: bytes   # 32 bytes

    @property
    def stealth_address(self) -> bytes:
        """
        Get public stealth address (view_public || spend_public).

        This is what the receiver shares with senders.
        """
        return self.view_public + self.spend_public


def generate_stealth_keys() -> StealthKeys:
    """
    Generate new stealth key pair for receiver.

    Returns:
        StealthKeys with view and spend keys
    """
    # Generate random secrets
    view_secret = secrets.token_bytes(32)
    spend_secret = secrets.token_bytes(32)

    # Derive public keys (simplified - in production use proper curve operations)
    view_public = sha3_256(b"MONTANA_VIEW_PK:" + view_secret).data
    spend_public = sha3_256(b"MONTANA_SPEND_PK:" + spend_secret).data

    return StealthKeys(
        view_secret=view_secret,
        view_public=view_public,
        spend_secret=spend_secret,
        spend_public=spend_public,
    )


def create_stealth_address(
    receiver_view_public: bytes,
    receiver_spend_public: bytes,
) -> Tuple[StealthAddress, bytes]:
    """
    Create one-time stealth address for receiver.

    Called by sender to create a unique address for the receiver.

    Args:
        receiver_view_public: Receiver's public view key
        receiver_spend_public: Receiver's public spend key

    Returns:
        (StealthAddress, ephemeral_secret) - sender keeps ephemeral_secret private
    """
    # Generate ephemeral keypair
    ephemeral_secret = secrets.token_bytes(32)
    tx_public_key = sha3_256(b"MONTANA_EPHEMERAL_PK:" + ephemeral_secret).data

    # Compute shared secret: ECDH(ephemeral_secret, receiver_view_public)
    # Simplified: in production use proper curve multiplication
    shared_secret = sha3_256(ephemeral_secret + receiver_view_public).data

    # Derive one-time public key
    # P = H(shared_secret) * G + receiver_spend_public
    # Simplified: hash-based derivation
    key_derivation = sha3_256(b"MONTANA_STEALTH_DERIVE:" + shared_secret).data
    one_time_public_key = sha3_256(key_derivation + receiver_spend_public).data

    # Compute view tag (first byte of H(shared_secret || "view_tag"))
    view_tag = sha3_256(shared_secret + b"view_tag").data[:1]

    stealth_addr = StealthAddress(
        one_time_public_key=one_time_public_key,
        tx_public_key=tx_public_key,
        view_tag=view_tag,
    )

    return stealth_addr, ephemeral_secret


def scan_stealth_address(
    stealth_addr: StealthAddress,
    view_secret: bytes,
    spend_public: bytes,
) -> Optional[bytes]:
    """
    Scan if stealth address belongs to receiver.

    Called by receiver to check if a transaction is for them.

    Args:
        stealth_addr: Stealth address from transaction
        view_secret: Receiver's secret view key
        spend_public: Receiver's public spend key

    Returns:
        One-time secret key if address matches, None otherwise
    """
    # Compute shared secret: ECDH(tx_public_key, view_secret)
    # Simplified version
    shared_secret = sha3_256(stealth_addr.tx_public_key + view_secret).data

    # Quick check with view tag
    expected_view_tag = sha3_256(shared_secret + b"view_tag").data[:1]
    if expected_view_tag != stealth_addr.view_tag:
        return None

    # Compute expected one-time public key
    key_derivation = sha3_256(b"MONTANA_STEALTH_DERIVE:" + shared_secret).data
    expected_otpk = sha3_256(key_derivation + spend_public).data

    if expected_otpk != stealth_addr.one_time_public_key:
        return None

    # Derive one-time secret key
    # x = H(shared_secret) + spend_secret
    # Simplified: we return a derivation that can be used with spend_secret
    return sha3_256(b"MONTANA_STEALTH_SECRET:" + shared_secret).data


def derive_spending_key(
    one_time_secret_derivation: bytes,
    spend_secret: bytes,
) -> bytes:
    """
    Derive the actual spending key for a stealth output.

    Args:
        one_time_secret_derivation: Output from scan_stealth_address
        spend_secret: Receiver's secret spend key

    Returns:
        Secret key that can spend the output
    """
    return sha3_256(one_time_secret_derivation + spend_secret).data
