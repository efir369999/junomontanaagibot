<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
@page {
    size: letter;
    margin: 1in;
    @bottom-center {
        content: counter(page);
        font-family: "Times New Roman", Times, serif;
        font-size: 10pt;
    }
}

body {
    font-family: "Times New Roman", Times, serif;
    font-size: 10pt;
    line-height: 1.2;
    max-width: 6.5in;
    margin: 0 auto;
}

h1.title {
    font-size: 17pt;
    font-weight: bold;
    text-align: center;
    margin-bottom: 12pt;
    margin-top: 0;
}

.author {
    text-align: center;
    font-size: 10pt;
    line-height: 1.4;
    margin-bottom: 18pt;
}

.abstract {
    margin-bottom: 12pt;
    text-align: justify;
    text-indent: 2em;
    line-height: 1.15;
}

.abstract-label {
    font-weight: bold;
    margin-left: -2em;
}

h2 {
    font-size: 12pt;
    font-weight: bold;
    margin-top: 12pt;
    margin-bottom: 6pt;
}

p {
    margin: 0 0 6pt 0;
    text-align: justify;
    text-indent: 2em;
}

p:first-of-type {
    text-indent: 0;
}

table {
    border-collapse: collapse;
    margin: 12pt auto;
    font-size: 9pt;
}

th, td {
    border: 1pt solid black;
    padding: 4pt 8pt;
    text-align: left;
}

.equation {
    text-align: center;
    margin: 12pt 0;
    font-style: italic;
}

.diagram {
    text-align: center;
    margin: 12pt 0;
    font-family: monospace;
    font-size: 9pt;
}

pre, code {
    font-family: "Courier New", monospace;
    font-size: 9pt;
}

pre {
    margin: 6pt 0;
    padding: 6pt;
    background: #f8f8f8;
}

ol, ul {
    margin: 6pt 0 12pt 24pt;
}

li {
    margin-bottom: 4pt;
}

.references {
    font-size: 9pt;
}

.references h2 {
    font-size: 12pt;
}
</style>
</head>
<body>

<h1 class="title">Montana: Finality from Sequential Computation</h1>

<div class="author">
Alejandro Montana<br>
github.com/afgrouptime<br>
x.com/tojesatoshi
</div>

<div class="abstract">
<span class="abstract-label">Abstract.</span>  A purely self-sovereign finality mechanism would allow distributed systems to achieve irreversible consensus without economic security or honest majority assumptions.  Verifiable Delay Functions provide part of the solution, but the main benefits are lost if finality still depends on external validators or stake.  We propose a solution to the finality problem using accumulated VDF checkpoints.  The system chains sequential computations by hashing each checkpoint into the next, forming a record that cannot be changed without redoing the sequential work.  The deepest VDF chain not only serves as proof of elapsed time, but proof that equivalent wallclock time was expended.  As long as physics holds, attackers cannot rewrite N checkpoints faster than N × T seconds regardless of computational resources.  The system requires minimal structure and no external dependencies.
</div>

<h2>1. Introduction</h2>

<p>Distributed systems have come to rely on external mechanisms to achieve finality.  Proof-of-work systems provide probabilistic finality through computational races.  Proof-of-stake systems provide economic finality through slashing conditions.  Byzantine fault tolerant systems provide deterministic finality through supermajority votes.  While these systems work well enough for most applications, they still suffer from the inherent weaknesses of the trust-based model.  Completely irreversible finality is not really possible, since validators can always collude and miners can always reorg.  The cost of mediation increases with value transferred, limiting practical finality for high-value transactions.  With the possibility of reversal, the need for trust spreads.  A certain probability of reorg is accepted as unavoidable.  These costs and finality uncertainties can be avoided if there existed a mechanism to achieve finality without trusted parties.</p>

<p>What is needed is a finality mechanism based on physical constraints instead of trust, allowing any node to verify finality independently without relying on external parties.  Computations that are physically impossible to accelerate would protect against rewriting history, and routine verification mechanisms could easily confirm elapsed time.  In this paper, we propose a solution to the finality problem using accumulated Verifiable Delay Function checkpoints to generate physical proof of elapsed time.  The system is secure as long as VDF sequentiality holds and adversaries operate within known physics.</p>

<h2>2. Temporal Time Unit</h2>

<p>We define a Temporal Time Unit as a cryptographic proof of elapsed time. The unit asymptotically approaches one second as verification evidence accumulates:</p>

<div class="equation">lim(evidence → ∞) 1 Ɉ → 1 second</div>

<p>Each owner transfers units by digitally signing a hash of the previous transaction and the public key of the next owner. A recipient can verify the signatures to verify the chain of ownership.</p>

<p>The problem of course is the recipient cannot verify that time actually passed. A common solution is to introduce a trusted timestamp authority, but this returns to the trust model. We need a way for any node to verify elapsed time without trusting a central party.</p>

<h2>3. VDF Checkpoint</h2>

<p>The solution we propose begins with a Verifiable Delay Function. A VDF works by computing T sequential hash iterations that cannot be parallelized:</p>

<div class="equation">VDF(x, T) = H<sup>T</sup>(x) = H(H(H(...H(x)...))) [T iterations]</div>

<p>The VDF proves that minimum time T has elapsed. Each checkpoint includes the previous checkpoint in its input, forming a chain:</p>

<div class="diagram">
┌─────────────┐     ┌─────────────┐     ┌─────────────┐<br>
│ Checkpoint  │     │ Checkpoint  │     │ Checkpoint  │<br>
│   C(i-1)    │────▶│    C(i)     │────▶│   C(i+1)    │<br>
└─────────────┘     └─────────────┘     └─────────────┘
</div>

<div class="equation">C<sub>i</sub> = VDF(C<sub>i-1</sub> || B<sub>i</sub>, T)</div>

<p>Where T = 2<sup>24</sup> iterations of SHAKE256, approximately 2.5 seconds.</p>

<h2>4. Accumulated Finality</h2>

<p>To accomplish finality without external trust, we accumulate VDF checkpoints. Each checkpoint requires T sequential computation. Reverting N checkpoints requires N × T sequential computation.</p>

<table>
<tr><th>Depth</th><th>Checkpoints</th><th>Attack Cost</th></tr>
<tr><td>Soft</td><td>1</td><td>2.5 seconds</td></tr>
<tr><td>Medium</td><td>100</td><td>4 minutes</td></tr>
<tr><td>Hard</td><td>1000</td><td>40 minutes</td></tr>
</table>

<p>An adversary with unbounded parallelism still needs N × 2.5 seconds of wallclock time to rewrite N checkpoints. This follows from VDF sequentiality—the same property that makes VDFs useful for randomness beacons.</p>

<p>The probability of an attacker catching up diminishes not exponentially with hashpower, but linearly with time deficit. There is no lucky catch-up. Time cannot be parallelized.</p>

<h2>5. Network</h2>

<p>The steps to run the network are as follows:</p>

<ol>
<li>New transactions are broadcast to all nodes.</li>
<li>Full nodes collect transactions and compute VDF checkpoints.</li>
<li>Each checkpoint chains to the previous, proving elapsed time.</li>
<li>Nodes accept the deepest valid VDF chain as canonical.</li>
<li>Light nodes verify checkpoint proofs without computing VDFs.</li>
</ol>

<p>Nodes always consider the deepest VDF chain to be correct. If two nodes broadcast different checkpoints simultaneously, nodes work on the first received. The tie breaks when the next VDF completes—whichever chain extends first becomes deeper.</p>

<p>New checkpoint broadcasts do not need to reach all nodes instantly. As long as they propagate before the next VDF period, the network maintains consistency.</p>

<h2>6. Incentive</h2>

<p>By convention, the first transaction in a block distributes new Temporal Time Units to participants. This provides incentive for nodes to support the network and distributes units into circulation without a central issuer.</p>

<p>The distribution follows a halving schedule:</p>

<table>
<tr><th>Era</th><th>Per Block</th><th>Cumulative</th></tr>
<tr><td>1</td><td>3,000 Ɉ (50 min)</td><td>50%</td></tr>
<tr><td>2</td><td>1,500 Ɉ (25 min)</td><td>75%</td></tr>
<tr><td>3</td><td>750 Ɉ (12.5 min)</td><td>87.5%</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>33</td><td>1 Ɉ (1 sec)</td><td>100%</td></tr>
</table>

<p>Total supply: 1,260,000,000 Ɉ = 21,000,000 minutes.</p>

<p>Pre-allocation: 0.</p>

<h2>7. Time Verification</h2>

<p><strong>Atomic Time Consensus.</strong> 34 NTP servers across 8 geographic regions provide time reference. Consensus requires >50% agreement within 1 second. This is engineering, not security—the VDF enforces minimum elapsed time regardless of reported clock values.</p>

<p><strong>VDF Proof.</strong> Each checkpoint proves T sequential iterations occurred. Verification is fast via STARK proofs. The VDF cannot be accelerated regardless of parallel resources.</p>

<h2>8. Privacy</h2>

<p>The necessity to announce all transactions publicly precludes traditional privacy, but privacy can be maintained by keeping public keys pseudonymous. The public sees that someone transfers an amount to someone else, but without information linking the transaction to anyone.</p>

<p>As an additional measure, a new key pair should be used for each transaction. Some linking is unavoidable with multi-input transactions, which reveal that inputs belong to the same owner.</p>

<p>Optional privacy tiers provide additional protection:</p>

<table>
<tr><th>Tier</th><th>Visibility</th></tr>
<tr><td>T0</td><td>Transparent</td></tr>
<tr><td>T1</td><td>Hidden recipient</td></tr>
<tr><td>T2</td><td>Hidden amount</td></tr>
<tr><td>T3</td><td>Full privacy</td></tr>
</table>

<h2>9. Calculations</h2>

<p>We consider the scenario of an attacker trying to rewrite history. Unlike probabilistic systems, the attacker cannot get lucky. Rewriting N checkpoints requires exactly N × T sequential computation.</p>

<p>Let d = attacker's time deficit in checkpoints. The time required to catch up:</p>

<div class="equation">t<sub>catch-up</sub> = d × T</div>

<p>During this time, honest nodes extend the chain by:</p>

<div class="equation">n<sub>honest</sub> = t<sub>catch-up</sub> / T = d</div>

<p>The attacker never catches up. The deficit remains constant or grows.</p>

<pre>
#include &lt;math.h&gt;

double TimeToRewrite(int checkpoints, double vdf_time)
{
    return checkpoints * vdf_time;
}

// Example: rewriting 1000 checkpoints
// TimeToRewrite(1000, 2.5) = 2500 seconds = 41.7 minutes
</pre>

<p>Results for various depths:</p>

<pre>
checkpoints=1      time=2.5 seconds
checkpoints=10     time=25 seconds
checkpoints=100    time=4.2 minutes
checkpoints=1000   time=41.7 minutes
checkpoints=10000  time=6.9 hours
</pre>

<h2>10. Post-Quantum Security</h2>

<p>The system uses post-quantum cryptographic primitives:</p>

<table>
<tr><th>Function</th><th>Primitive</th><th>Standard</th></tr>
<tr><td>Signatures</td><td>SPHINCS+-SHAKE-128f</td><td>NIST FIPS 205</td></tr>
<tr><td>Key Exchange</td><td>ML-KEM-768</td><td>NIST FIPS 203</td></tr>
<tr><td>Hashing</td><td>SHA3-256, SHAKE256</td><td>NIST FIPS 202</td></tr>
<tr><td>VDF</td><td>Iterated SHAKE256</td><td>—</td></tr>
</table>

<p>The VDF construction uses hash iteration, which remains secure against quantum computers. Grover's algorithm provides at most quadratic speedup for search, but does not break sequential iteration.</p>

<h2>11. Assumptions</h2>

<p>The security model rests on explicit assumptions:</p>

<ol>
<li><strong>VDF Sequentiality.</strong> No algorithm computes H<sup>T</sup>(x) faster than T sequential evaluations. If broken, finality degrades to the broken primitive's security.</li>
<li><strong>Hash Integrity.</strong> SHAKE256 has no structural weakness enabling iteration shortcuts. If broken, same degradation.</li>
<li><strong>Physical Bounds.</strong> Adversaries operate within known physics. Cannot reverse causality, signal faster than light, or compute without energy. If broken, all cryptography fails.</li>
</ol>

<h2>12. Conclusion</h2>

<p>We have proposed a system for finality without relying on economic security or honest majority. We started with the framework of Verifiable Delay Functions, which provide sequential computation guarantees, but are incomplete without a way to accumulate finality. To solve this, we proposed chaining VDF checkpoints such that reverting N of them requires N × T wallclock time.</p>

<p>The system provides finality bounded by physics. Nodes verify independently by checking the VDF chain. No validators to query, no stake to count, no attestations to trust. The proof is the computation itself.</p>

<p>As long as VDF sequentiality holds and adversaries operate within known physics, the accumulated VDF chain provides finality that cannot be reversed without expending equivalent time.</p>

<div class="references">
<h2>References</h2>
<ol>
<li>D. Boneh, J. Bonneau, B. Bünz, B. Fisch, "Verifiable Delay Functions," CRYPTO 2018.</li>
<li>NIST FIPS 202, "SHA-3 Standard," 2015.</li>
<li>NIST FIPS 203, "Module-Lattice-Based Key-Encapsulation Mechanism," 2024.</li>
<li>NIST FIPS 205, "Stateless Hash-Based Digital Signature Standard," 2024.</li>
<li>L. Lamport, "Time, Clocks, and the Ordering of Events," 1978.</li>
<li>Y. Sompolinsky, A. Zohar, "PHANTOM," 2018.</li>
<li>S. Haber, W.S. Stornetta, "How to Time-Stamp a Digital Document," 1991.</li>
</ol>
</div>

</body>
</html>
